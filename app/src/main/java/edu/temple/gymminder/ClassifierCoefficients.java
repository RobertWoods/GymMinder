package edu.temple.gymminder;

import java.util.ArrayList;

/**
 * Created by nickdellosa on 4/26/17.
 */

public class ClassifierCoefficients {

    public final double coefpure;
    public final double coefdst;
    public final double coefmin;
    public final double coefmax;
    public final double coefsd;
    public final double coefrms;
    public final double coefdur;

    public static final int NUMCOEFFICIENTS = 6;

    public ClassifierCoefficients(double coefpure, double coefdst, double coefmin, double coefmax, double coefsd, double coefrms, double coefdur) {
        this.coefpure = coefpure;
        this.coefdst = coefdst;
        this.coefmin = coefmin;
        this.coefmax = coefmax;
        this.coefsd = coefsd;
        this.coefrms = coefrms;
        this.coefdur = coefdur;
    }

    public ClassifierCoefficients(double[] coefs) {
        this(coefs[0], coefs[1], coefs[2], coefs[3], coefs[4], coefs[5], coefs[6]);
    }

    /**
     * Returns the coefficient generated by the classifier at each particular index.
     *
     * @param index the index of the coefficient to return
     * @return the coefficient at index
     */
    public double getCoefficientAtIndex(int index) {
        switch (index) {
            case 0:
                return coefpure;
            case 1:
                return coefdst;
            case 2:
                return coefmin;
            case 3:
                return coefmax;
            case 4:
                return coefsd;
            case 5:
                return coefrms;
            case 6:
                return coefdur;
            default:
                throw new RuntimeException("Attribute at index " + index + " does not exist.");
        }
    }

    /**
     * Generates the coefficients for false-positive detection based on a logistic regression classifier trained using calibration data.
     *
     * @param goodBounds The bounds of good repetitions.
     * @param badBounds  The bounds of false-positive repetitions.
     * @return The coefficients generated by the logistic regression.
     */
    public static ClassifierCoefficients generateCoefficients(ArrayList<DataUtils.DetectedBounds> goodBounds, ArrayList<DataUtils.DetectedBounds> badBounds) {
        ArrayList<double[]> allBounds = new ArrayList<>();
        double[] outcomes = new double[goodBounds.size() + badBounds.size()];
        for (int i=0; i < goodBounds.size(); i++) {
            allBounds.add(goodBounds.get(i).getAsArray());
            outcomes[i] = 1;
        }
        for (int i=0; i < badBounds.size(); i++) {
            allBounds.add(badBounds.get(i).getAsArray());
            outcomes[goodBounds.size()+i] = 0;
        }
        double[][] nallBounds = new double[outcomes.length][NUMCOEFFICIENTS];
        LogisticRegression lr = new LogisticRegression(allBounds.toArray(nallBounds), outcomes);
        return new ClassifierCoefficients(lr.beta);
    }

    private static double getAttributeValue(DataUtils.DetectedBounds bounds, int index) {
        switch (index) {
            case 1:
                return bounds.dst;
            case 2:
                return bounds.min;
            case 3:
                return bounds.max;
            case 4:
                return bounds.sd;
            case 5:
                return bounds.rms;
            case 6:
                return bounds.dur;
            default:
                throw new RuntimeException("Attribute at index " + index + " does not exist.");
        }
    }

    public static class LogisticRegression {
        private final int N;    // number of total items
        private final int P;    // number of predictors
        private final double[] beta;  // regression coefficients

        public LogisticRegression(double[][] x, double[] y) {
            if (x.length != y.length) throw new RuntimeException("Invalid dimensions");
            if (x == null || y == null || x.length == 0 || y.length == 0) throw new RuntimeException("Input arrays cannot be null");

            // setup variables
            N = y.length;
            P = x[0].length;
            beta = new double[P + 1];
            double totalTrueOutcomes = 0.0;
            double totalFalseOutcomes = 0.0;
            double oTrue = 0.0;
            double oFalse = 0.0;
            double logit = 0.0;
            double totalTrueItems = 0.0;
            double totalFalseItems = 0.0;
            double oTotal = 0.0;
            double totalLogit = 0.0;

            // beta0 coefficient calculation
            for(int j = 0; j < P; j++){
                totalTrueOutcomes = 0.0;
                totalFalseOutcomes = 0.0;
                totalTrueItems = 0.0;
                totalFalseItems = 0.0;
                for(int i = 0; i < N; i++){
                    if(y[i] != 0){
                        if(x[i][j] == 0){
                            totalFalseOutcomes++;
                        }
                    }
                    if(x[i][j] == 0){
                        totalFalseItems++;
                    }
                }
                // calculate odds of predictor being false with outcome true
                oTotal = (totalFalseOutcomes / totalFalseItems)
                        / ((totalFalseItems - totalFalseOutcomes) / totalFalseItems);
                logit = Math.log(oTotal);   // log of odds (coefficient)
                totalLogit += logit;
            }
            // store coefficient
            beta[0] = totalLogit;

            // all other beta values
            for(int j = 0; j < P; j++){
                totalTrueOutcomes = 0.0;
                totalFalseOutcomes = 0.0;
                totalTrueItems = 0.0;
                totalFalseItems = 0.0;
                for(int i = 0; i < N; i++){
                    if(y[i] != 0){
                        if(x[i][j] != 0){
                            totalTrueOutcomes++;
                        }else{
                            totalFalseOutcomes++;
                        }
                    }
                    if(x[i][j] != 0){
                        totalTrueItems++;
                    }else{
                        totalFalseItems++;
                    }
                }
                // calculate ratio of odds
                oTrue = totalTrueOutcomes / (totalTrueItems - totalTrueOutcomes);
                oFalse = totalFalseOutcomes / (totalFalseItems - totalFalseOutcomes);
                oTotal = oTrue / oFalse;
                // check if predictor had effect on outcome
                if(oTotal != 0){
                    // find log of odds which is the coefficient
                    logit = Math.log(oTotal);
                    // store coefficient
                    beta[j + 1] = logit;
                }else{
                    // store 0 because predictor has no effect on outcome
                    beta[j + 1] = 0.0;
                }
            }

            // output results
            System.out.println("\nResults Summary");
            System.out.println("________________");
            System.out.println("| Beta   Coeff |");
            System.out.println("|------|-------|");
            for(int i = 0; i < beta.length; i++){
                System.out.format("|%6d|%7.4f|\n", i, beta[i]);
            }
            System.out.println("|______|_______|\n");


        }
    }
}
